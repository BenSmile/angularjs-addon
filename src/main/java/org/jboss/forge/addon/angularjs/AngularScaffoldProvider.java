/**
 * Copyright 2014 Red Hat, Inc. and/or its affiliates.
 *
 * Licensed under the Eclipse Public License version 1.0, available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.jboss.forge.addon.angularjs;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.JarURLConnection;
import java.net.URL;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

import org.jboss.forge.addon.facets.FacetFactory;
import org.jboss.forge.addon.javaee.cdi.CDIFacet;
import org.jboss.forge.addon.javaee.cdi.ui.CDISetupCommand;
import org.jboss.forge.addon.javaee.ejb.EJBFacet;
import org.jboss.forge.addon.javaee.ejb.ui.EJBSetupWizard;
import org.jboss.forge.addon.javaee.jpa.JPAFacet;
import org.jboss.forge.addon.javaee.jpa.ui.setup.JPASetupWizard;
import org.jboss.forge.addon.javaee.rest.RestFacet;
import org.jboss.forge.addon.javaee.rest.ui.RestEndpointFromEntityCommand;
import org.jboss.forge.addon.javaee.rest.ui.setup.RestSetupWizard;
import org.jboss.forge.addon.javaee.servlet.ServletFacet;
import org.jboss.forge.addon.javaee.servlet.ServletFacet_3_0;
import org.jboss.forge.addon.javaee.servlet.ServletFacet_3_1;
import org.jboss.forge.addon.javaee.servlet.ui.ServletSetupWizard;
import org.jboss.forge.addon.parser.java.facets.JavaSourceFacet;
import org.jboss.forge.addon.parser.java.resources.JavaResource;
import org.jboss.forge.addon.projects.facets.DependencyFacet;
import org.jboss.forge.addon.projects.facets.MetadataFacet;
import org.jboss.forge.addon.projects.facets.WebResourcesFacet;
import org.jboss.forge.addon.resource.FileResource;
import org.jboss.forge.addon.resource.ResourceFactory;
import org.jboss.forge.addon.resource.ResourceFilter;
import org.jboss.forge.addon.scaffold.metawidget.MetawidgetInspectorFacade;
import org.jboss.forge.addon.scaffold.spi.ScaffoldGenerationContext;
import org.jboss.forge.addon.scaffold.spi.ScaffoldSetupContext;
import org.jboss.forge.addon.scaffold.ui.ScaffoldSetupWizard;
import org.jboss.forge.addon.templates.facets.TemplateFacet;
import org.jboss.forge.addon.ui.command.UICommand;
import org.jboss.forge.addon.ui.result.NavigationResult;
import org.jboss.forge.addon.projects.Project;
import org.jboss.forge.addon.resource.Resource;
import org.jboss.forge.addon.scaffold.spi.AccessStrategy;
import org.jboss.forge.addon.scaffold.spi.ScaffoldProvider;
import org.jboss.forge.addon.ui.result.navigation.NavigationResultBuilder;
import org.jboss.forge.addon.ui.util.Metadata;
import org.jboss.forge.parser.java.JavaClass;
import org.jboss.forge.parser.java.JavaSource;
import org.jboss.forge.parser.java.util.Strings;
import org.jboss.shrinkwrap.descriptor.api.webapp30.WebAppDescriptor;
import org.jboss.shrinkwrap.descriptor.api.webcommon30.WelcomeFileListType;
import org.metawidget.util.simple.StringUtils;

import javax.enterprise.event.Event;
import javax.inject.Inject;

import static org.jboss.forge.addon.angularjs.ResourceProvider.*;

/**
 * A {@link ScaffoldProvider} that generates AngularJS scaffolding from JPA entities. The generated scaffold is utilizes
 * the REST (JAX-RS) resources generated by the Java EE addon.
 */
public class AngularScaffoldProvider implements ScaffoldProvider
{

   public static final String SCAFFOLD_DIR = "/scaffold";

   Project project;

   @Inject
   private FacetFactory facetFactory;

   @Inject
   private ResourceFactory resourceFactory;

   @Inject
   private Event<CopyWebResourcesEvent> copyResourcesEvent;

   @Inject
   private Event<ProcessWithFreemarkerEvent> processWithFreemarkerEvent;

   @Inject
   private ResourceRegistry resourceRegistry;

   @Override
   public String getName()
   {
      return "AngularJS";
   }

   @Override
   public String getDescription()
   {
      return "Scaffold a RESTful service and an AngularJS client, from JPA entities";
   }

   @Override
   public List<Resource<?>> setup(Project project, ScaffoldSetupContext setupContext)
   {
      setProject(project);
      String targetDir = setupContext.getTargetDirectory();
      targetDir = (targetDir == null) ? "" : targetDir;
      boolean overwrite = setupContext.isOverwrite();

      // Setup static resources.
      ArrayList<Resource<?>> result = new ArrayList<>();
      copyResourcesEvent.fire(new CopyWebResourcesEvent(project, getStatics(targetDir), overwrite));
      result.addAll(resourceRegistry.getCreatedResources());
      return result;
   }

   @Override
   public boolean isSetup(ScaffoldSetupContext setupContext)
   {
      String targetDir = setupContext.getTargetDirectory();
      targetDir = targetDir == null ? "" : targetDir;
      if (project.hasAllFacets(WebResourcesFacet.class, DependencyFacet.class, JPAFacet.class, EJBFacet.class,
               CDIFacet.class, RestFacet.class))
      {
         WebResourcesFacet web = this.project.getFacet(WebResourcesFacet.class);
         boolean areResourcesInstalled = web.getWebResource(targetDir + GLYPHICONS_SVG).exists()
                  && web.getWebResource(targetDir + GLYPHICONS_EOT).exists()
                  && web.getWebResource(targetDir + GLYPHICONS_SVG).exists()
                  && web.getWebResource(targetDir + GLYPHICONS_TTF).exists()
                  && web.getWebResource(targetDir + GLYPHICONS_WOFF).exists()
                  && web.getWebResource(targetDir + FORGE_LOGO_PNG).exists()
                  && web.getWebResource(targetDir + ANGULAR_RESOURCE_JS).exists()
                  && web.getWebResource(targetDir + ANGULAR_ROUTE_JS).exists()
                  && web.getWebResource(targetDir + ANGULAR_JS).exists()
                  && web.getWebResource(targetDir + MODERNIZR_JS).exists()
                  && web.getWebResource(targetDir + JQUERY_JS).exists()
                  && web.getWebResource(targetDir + BOOTSTRAP_JS).exists()
                  && web.getWebResource(targetDir + OFFCANVAS_JS).exists()
                  && web.getWebResource(targetDir + MAIN_CSS).exists()
                  && web.getWebResource(targetDir + BOOTSTRAP_CSS).exists()
                  && web.getWebResource(targetDir + BOOTSTRAP_THEME_CSS).exists()
                  && web.getWebResource(targetDir + LANDING_VIEW).exists();
         return areResourcesInstalled;
      }
      return false;
   }

   @Override
   public List<Resource<?>> generateFrom(Project project, ScaffoldGenerationContext scaffoldGenerationContext)
   {
      setProject(project);
      String targetDir = scaffoldGenerationContext.getTargetDirectory();
      targetDir = (targetDir == null) ? "" : targetDir;
      boolean overwrite = scaffoldGenerationContext.isOverwrite();
      List<Resource<?>> result = new ArrayList<>();
      Collection<Resource<?>> resources = scaffoldGenerationContext.getResources();
      for (Resource<?> resource : resources)
      {
         JavaSource<?> javaSource = null;
         if (resource instanceof JavaResource)
         {
            JavaResource javaResource = (JavaResource) resource;
            try
            {
               javaSource = javaResource.getJavaSource();
            }
            catch (FileNotFoundException fileEx)
            {
               throw new IllegalStateException(fileEx);
            }
         }
         else
         {
            continue;
         }

         JavaClass entity = (JavaClass) javaSource;
         String resourceRootPath = getRootResourcePath(project);
         String entityResourcePath = parseResourcePath(entity);
         if (entityResourcePath == null || entityResourcePath.isEmpty())
         {
            entityResourcePath = entity.getName().toLowerCase() + "s";
         }
         /*
          * TODO Generate REST resources and then obtain the REST URIs.
          * entityResourcePath = prompt.prompt("What REST URI under /" +
          * resourceRootPath + " should be used to locate instances of type [" + klass.getQualifiedName() + "] ?",
          * entityResourcePath);
          */
         entityResourcePath = trimSlashes(entityResourcePath);

         // Inspect the JPA entity and obtain a list of inspection results. Every inspected property is represented as a
         // Map<String,String> and all such inspection results are collated into a list.
         MetawidgetInspectorFacade metawidgetInspectorFacade = new MetawidgetInspectorFacade(project);
         InspectionResultProcessor angularResultEnhancer = new InspectionResultProcessor(project,
                  metawidgetInspectorFacade);
         List<Map<String, String>> inspectionResults = metawidgetInspectorFacade.inspect(entity);
         String entityId = angularResultEnhancer.fetchEntityId(entity, inspectionResults);
         inspectionResults = angularResultEnhancer.enhanceResults(entity, inspectionResults);

         MetadataFacet metadata = project.getFacet(MetadataFacet.class);

         // TODO: Provide a 'utility' class for allowing transliteration across language naming schemes
         // We need this to use contextual naming schemes instead of performing toLowerCase etc. in FTLs.

         // Prepare the Freemarker data model
         Map<String, Object> root = new HashMap<String, Object>();
         root.put("entityName", entity.getName());
         root.put("entityId", entityId);
         root.put("properties", inspectionResults);
         root.put("projectId", StringUtils.camelCase(metadata.getProjectName()));
         root.put("projectTitle", StringUtils.uncamelCase(metadata.getProjectName()));
         root.put("resourceRootPath", resourceRootPath);
         root.put("resourcePath", entityResourcePath);
         root.put("parentDirectories", getParentDirectories(targetDir));

         // Process the Freemarker templates with the Freemarker data model and retrieve the generated resources from
         // the registry.
         processWithFreemarkerEvent.fire(new ProcessWithFreemarkerEvent(project,
                  getEntityTemplates(targetDir, entity.getName()),
                  root, overwrite));
         result.addAll(resourceRegistry.getCreatedResources());
      }

      List<Resource<?>> indexResources = generateIndex(targetDir, overwrite);
      result.addAll(indexResources);
      return result;
   }

   @Override
   public NavigationResult getSetupFlow(Project project)
   {
      NavigationResultBuilder builder = NavigationResultBuilder.create();
      List<Class<? extends UICommand>> setupCommands = new ArrayList<>();
      if (!project.hasFacet(JPAFacet.class))
      {
         builder.add(JPASetupWizard.class);
      }
      if (!project.hasFacet(CDIFacet.class))
      {
         setupCommands.add(CDISetupCommand.class);
      }
      if (!project.hasFacet(EJBFacet.class))
      {
         setupCommands.add(EJBSetupWizard.class);
      }
      if (!project.hasFacet(ServletFacet.class))
      {
         // TODO: FORGE-1296. Ensure that this wizard only sets up Servlet 3.0+
         setupCommands.add(ServletSetupWizard.class);
      }
      if (!project.hasFacet(RestFacet.class))
      {
         setupCommands.add(RestSetupWizard.class);
      }

      Metadata compositeSetupMetadata = Metadata.forCommand(ScaffoldSetupWizard.class)
               .name("Setup Facets")
               .description("Setup all dependent facets for the AngularJS scaffold.");
      builder.add(compositeSetupMetadata, setupCommands);
      return builder.build();
   }

   @Override
   public NavigationResult getGenerationFlow(Project project)
   {
      NavigationResultBuilder builder = NavigationResultBuilder.create();
      builder.add(ScaffoldableEntitySelectionWizard.class);
      builder.add(RestEndpointFromEntityCommand.class);
      return builder.build();
   }

   @Override
   public AccessStrategy getAccessStrategy()
   {
      return null;
   }

   public void setProject(Project project)
   {
      this.project = project;
   }

   /**
    * Generates the application's index aka landing page, among others. All artifacts that are generated once per
    * scaffolding run are generated here.
    * 
    * @param targetDir The target directory for the generated scaffold artifacts.
    * @param overwrite A flag that indicates whether existing resources should be overwritten or not.
    * @return A list of generated {@link Resource}s
    */
   public List<Resource<?>> generateIndex(String targetDir, boolean overwrite)
   {
      ArrayList<Resource<?>> result = new ArrayList<>();

      /*
       * TODO: Revert this change at a later date, if necessary. This is currently done to ensure that entities are
       * picked up during invocation of the plugin from the Forge wizard in JBDS.
       */
      ResourceFilter filter = new ResourceFilter()
      {
         @Override
         public boolean accept(Resource<?> resource)
         {
            FileResource<?> file = (FileResource<?>) resource;

            if (!file.isDirectory() || file.getName().equals("resources") || file.getName().equals("WEB-INF")
                     || file.getName().equals("META-INF"))
            {
               return false;
            }

            return true;
         }
      };

      WebResourcesFacet web = this.project.getFacet(WebResourcesFacet.class);
      List<Resource<?>> resources = web.getWebResource(targetDir + "/views/").listResources(filter);
      List<String> entityNames = new ArrayList<>();
      for (Resource<?> resource : resources)
      {
         entityNames.add(resource.getName());
      }

      MetadataFacet metadata = project.getFacet(MetadataFacet.class);

      Map<String, Object> root = new HashMap<>();
      root.put("entityNames", entityNames);
      root.put("projectId", StringUtils.camelCase(metadata.getProjectName()));
      root.put("projectTitle", StringUtils.uncamelCase(metadata.getProjectName()));
      root.put("targetDir", targetDir);

      processWithFreemarkerEvent.fire(new ProcessWithFreemarkerEvent(project, getGlobalTemplates(targetDir), root, overwrite));
      result.addAll(resourceRegistry.getCreatedResources());
      configureWelcomeFile();
      return result;
   }

   /**
    * Configures the welcome file entry in the project's web application descriptor to the static ever-present
    * <code>index.html</code> file. This method adds the entry only if it is absent.
    */
   private void configureWelcomeFile()
   {
      String indexFileEntry = "/index.html";

      ServletFacet servlet = this.project.getFacet(ServletFacet.class);
      if (servlet instanceof ServletFacet_3_0)
      {
         WebAppDescriptor servletConfig = (WebAppDescriptor) servlet.getConfig();
         servletConfig.getOrCreateWelcomeFileList().welcomeFile(indexFileEntry);
         servlet.saveConfig(servletConfig);
      }
      else if (servlet instanceof ServletFacet_3_1)
      {
         org.jboss.shrinkwrap.descriptor.api.webapp31.WebAppDescriptor servletConfig = (org.jboss.shrinkwrap.descriptor.api.webapp31.WebAppDescriptor) servlet
                  .getConfig();
         servletConfig.getOrCreateWelcomeFileList().welcomeFile(indexFileEntry);
         servlet.saveConfig(servletConfig);
      }
      return;
   }

   /**
    * Installs the templates into src/main/templates. All Freemarker templates would be copied into the
    * src/main/templates/angularjs directory, obeying the same structure as the one in this provider.
    */
   private void installTemplates()
   {
      // Install the required facet so that the templates directory is created if not present.
      if (!project.hasFacet(TemplateFacet.class))
      {
         facetFactory.install(project, TemplateFacet.class);
      }

      TemplateFacet templates = project.getFacet(TemplateFacet.class);
      // Obtain a reference to the scaffold directory in the classpath
      URL resource = getClass().getClassLoader().getResource("scaffold");
      if (resource != null && resource.getProtocol().equals("jar"))
      {
         try
         {
            // Obtain a reference to the JAR containing the scaffold directory
            JarURLConnection connection = (JarURLConnection) resource.openConnection();
            JarFile jarFile = connection.getJarFile();
            Enumeration<JarEntry> entries = jarFile.entries();
            // Iterate through the JAR entries and copy files to the template directory. Only files ending with .ftl,
            // and
            // present in the scaffold/ directory are copied.
            while (entries.hasMoreElements())
            {
               JarEntry jarEntry = entries.nextElement();
               String entryName = jarEntry.getName();
               if (entryName.startsWith("scaffold/") && entryName.endsWith(".ftl"))
               {
                  String relativeFilename = entryName.substring("scaffold/".length());
                  InputStream is = jarFile.getInputStream(jarEntry);
                  // Copy the file into a sub-directory under src/main/templates named after the scaffold provider.
                  Resource<File> templateResource = resourceFactory.create(new File(relativeFilename));
                  FileResource fileResource = templateResource.reify(FileResource.class);
                  fileResource.setContents(is);
               }
            }
         }
         catch (IOException ioEx)
         {
            throw new RuntimeException(ioEx);
         }
      }
   }

   private String parseResourcePath(JavaClass klass)
   {
      JavaSourceFacet java = project.getFacet(JavaSourceFacet.class);
      ResourcePathVisitor visitor = new ResourcePathVisitor(klass.getName());
      java.visitJavaSources(visitor);
      return visitor.getPath();
   }

   /**
    * Obtains the root path for REST resources so that the AngularJS resource factory will be generated with the correct
    * REST resource URL.
    * 
    * @return The root path of the REST resources generated by the Forge REST plugin.
    */
   private String getRootResourcePath(Project project)
   {
      RestFacet rest = project.getFacet(RestFacet.class);
      String resourceRootPath = trimSlashes(rest.getApplicationPath());
      return resourceRootPath;
   }

   /**
    * Provided a target directory, this method calculates the parent directories to re-create the path to the web
    * resource root.
    * 
    * @param targetDir The target directory that would be used as the basis for calculating the parent directories.
    * @return The parent directories to traverse. Represented as a sequence of '..' characters with '/' to denote
    *         multiple parent directories.
    */
   private String getParentDirectories(String targetDir)
   {
      if (targetDir == null || targetDir.isEmpty())
      {
         return "";
      }
      else
      {
         targetDir = trimSlashes(targetDir);
         int parents = countOccurrences(targetDir, '/') + 1;
         StringBuilder parentDirectories = new StringBuilder();
         for (int ctr = 0; ctr < parents; ctr++)
         {
            parentDirectories.append("../");
         }
         return parentDirectories.toString();
      }
   }

   private int countOccurrences(String searchString, char charToSearch)
   {
      int count = 0;
      for (int ctr = 0; ctr < searchString.length(); ctr++)
      {
         if (searchString.charAt(ctr) == charToSearch)
         {
            count++;
         }
      }
      return count;
   }

   private String trimSlashes(String aString)
   {
      if (aString.startsWith("/"))
      {
         aString = aString.substring(1);
      }
      if (aString.endsWith("/"))
      {
         aString = aString.substring(0, aString.length() - 1);
      }
      return aString;
   }

}
